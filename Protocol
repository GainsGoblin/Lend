// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7d17acfb2f12be0a2ad4c08ad4a3d823704b68d6/contracts/utils/math/SafeMath.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
    function mint(address account, uint256 amount) external;
    function burn(address account, uint256 amount) external;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IVault {
    function allWhitelistedTokensLength() external view returns (uint256);
    function allWhitelistedTokens(uint) external view returns (address);
}

interface IRewardTracker {
    function depositBalances(address _account, address _depositToken) external view returns (uint256);
    function stakedAmounts(address _account) external view returns (uint256);
    function updateRewards() external;
    function stake(address _depositToken, uint256 _amount) external;
    function stakeForAccount(address _fundingAccount, address _account, address _depositToken, uint256 _amount) external;
    function unstake(address _depositToken, uint256 _amount) external;
    function unstakeForAccount(address _account, address _depositToken, uint256 _amount, address _receiver) external;
    function tokensPerInterval() external view returns (uint256);
    function claim(address _receiver) external returns (uint256);
    function claimForAccount(address _account, address _receiver) external returns (uint256);
    function claimable(address _account) external view returns (uint256);
    function averageStakedAmounts(address _account) external view returns (uint256);
    function cumulativeRewards(address _account) external view returns (uint256);
}

interface IRewardsRouter {
    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns (uint256);
}

contract collateralizeGLP {

    using SafeMath for uint;

    mapping(address => bool) public borrowToken; // Token allowed to be deposited/borrowed
    mapping(address => address) public priceFeed; // Price feed for token
    mapping(address => address) public borrowShare; // Share token from lent token
    mapping(address => uint) public borrowTokenBalance; // Tracks balance of lent tokens

    mapping(address => address) public collateralTokenPriceFeed; // Price feed for tokens
    mapping(address => uint) public tokenDebt; // Tracks amount of tokens owed
    mapping(address => mapping(address => uint)) public borrowedAmount; // User debt
    mapping(address => uint) public interestCheckpoint; // Tracks token accrued interest using time

    uint256 public totalCollateral; // Total GLP deposited

    address public governance;
    IVault public vault;
    IRewardsRouter public rewardsRouter;
    IERC20 public GLPShare;
    address public GLP;
    address public fGLP;
    address public fsGLP;
    uint public ltv = 50; // 100 is 100% GLP LTV
    address public stakeReward;

    constructor(address _vault, address _rewardsRouter) {
        governance = msg.sender;
        rewardsRouter = IRewardsRouter(_rewardsRouter);
        vault = IVault(_vault);
    }



    // End user functions

    function depositCollateral(uint256 amount) external {
        uint amountToMint = amount.mul(1e18).div(getCollateralShareValue());
        IERC20(GLP).transferFrom(msg.sender, address(this), amount);
        IERC20(GLPShare).mint(msg.sender, amountToMint);
        totalCollateral += amount;
    }

    function withdrawCollateralAll() external {
        require(accountBorrowedValue(msg.sender) == 0, "Account has debt");
        uint shareAmount = IERC20(GLPShare).balanceOf(msg.sender);
        withdrawCollateral(shareAmount);
    }

    function withdrawCollateral(uint256 shareAmount) public {
        IERC20(GLPShare).burn(msg.sender, shareAmount);
        uint amount = shareAmount.mul(getCollateralShareValue()).div(1e18);
        IERC20(GLP).transfer(msg.sender, amount);
        totalCollateral -= amount;
        require(accountHealth(msg.sender) >= 1e18, "Account not healthy after withdraw");
    }

    function lend(address token, uint256 amount) external {
        require(borrowToken[token] == true, "Token not allowed");
        uint amountToMint = amount.mul(1e18).div(getShareValue(token));
        tokenDebt[token] += getTokenAccruedInterest(token);
        interestCheckpoint[token] = block.timestamp;
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        IERC20(borrowShare[token]).mint(msg.sender, amountToMint);
        borrowTokenBalance[token] += amount;
    }

    function withdrawAll(address token) external {
        uint shareAmount = IERC20(borrowShare[token]).balanceOf(msg.sender);
        withdraw(token, shareAmount);
    }

    function withdraw(address token, uint256 shareAmount) public {
        uint amountToSend = shareAmount.mul(getShareValue(token)).div(1e18);
        require(amountToSend > IERC20(token).balanceOf(address(this)), "Too much borrowed from liquidity to withdraw");
        IERC20(borrowShare[token]).burn(msg.sender, shareAmount);
        borrowTokenBalance[token] -= amountToSend;
        tokenDebt[token] += getTokenAccruedInterest(token);
        interestCheckpoint[token] = block.timestamp;        
        IERC20(token).transfer(msg.sender, amountToSend);
    }

    function borrow(address token, uint256 tokenAmount) external {
        require(borrowingPower(msg.sender, token) >= tokenAmount, "Not enough borrowing power");
        tokenDebt[token] += getTokenAccruedInterest(token);
        interestCheckpoint[token] = block.timestamp;
        tokenDebt[token] += tokenAmount; 
        borrowedAmount[msg.sender][token] += tokenAmount.mul(1e18).div(debtValue(token));
        IERC20(token).transfer(msg.sender, tokenAmount);
    }

    function repay(address token, uint256 tokenAmount) public {
        require(tokenAmount <= userDebt(msg.sender, token), "Repaying too much");      
        borrowedAmount[msg.sender][token] -= tokenAmount.mul(1e18).div(debtValue(token));
        tokenDebt[token] += getTokenAccruedInterest(token);
        interestCheckpoint[token] = block.timestamp;
        tokenDebt[token] -= tokenAmount;
        IERC20(token).transferFrom(msg.sender, address(this), tokenAmount);
    }

    function repayAll(address token) external {
        repay(token, userDebt(msg.sender, token));
    }

    function liquidate(address account) external {
        require(accountHealth(account) < 1e18, "Account healthy");
        uint256 usdLoansTotal = accountBorrowedValue(account);
        uint256 amount;
        address token;
        for (uint i=0; i<vault.allWhitelistedTokensLength(); i++) {
            token = vault.allWhitelistedTokens(i);
            amount = rewardsRouter.unstakeAndRedeemGlp(
                token,
                GLPShare.balanceOf(account).mul(getCollateralShareValue().div(1e18)).mul(userDebtUSD(account, token)).div(usdLoansTotal),
                1,
                address(this)
            );
            IERC20(token).transfer(msg.sender, amount.mul(5).div(100));
            IERC20(token).transfer(stakeReward, amount.mul(5).div(100));
        }
    }



    // Governance functions

    function setGovernance(address _governance) external {
        require(msg.sender == governance, "!Governance");
        governance = _governance;
    }

    function setBorrowToken(address token, address share, address _priceFeed) external {
        require(msg.sender == governance, "!Governance");
        require(borrowShare[token] == address(0), "!Governance");
        borrowShare[token] = share;
        priceFeed[token] = _priceFeed;
        borrowToken[token] = true;
    }

    function setBorrowTokenAllowed(address token, bool allowed) external {
        require(msg.sender == governance, "!Governance");
        borrowToken[token] = allowed;
    }

    function setCollateralTokenFeed(address token, address feed) external {
        require(msg.sender == governance, "!Governance");
        collateralTokenPriceFeed[token] = feed;
    }

    function setltv(uint _ltv) external {
        require(msg.sender == governance, "!Governance");
        require(_ltv <= 90 && _ltv >= ltv, "Invalid LTV"); // Decreasing LTV causes unfair liquidations
        ltv = _ltv;
    }



    // View functions

    // Value of a debt "token"
    function debtValue(address token) public view returns (uint256) { // 1e18 precision
        return (tokenDebt[token].add(getTokenAccruedInterest(token))).mul(1e18).div(totalBorrowedAmount(token));
    }

    // Interest on token since last checkpoint
    function getTokenAccruedInterest(address token) public view returns (uint256) { // 1e18 precision
        uint secondsBorrowed = block.timestamp.sub(interestCheckpoint[token]);
        uint interest = tokenDebt[token].mul(secondsBorrowed).div(31536000); // 31536000 seconds in a year
        return interest;
    }

    // How many tokens does an user owe
    function userDebt(address account, address token) public view returns (uint256) {
        return borrowedAmount[account][token].mul(debtValue(token)).div(1e18);
    }

    // How much USD does an user owe per token
    function userDebtUSD(address account, address token) public view returns (uint256) {
        return userDebt(account, token).mul(getLatestPrice(token)).div(1e18);
    }

    // How many lent tokens is it's share token backed by
    function getShareValue(address token) public view returns (uint256) {
        if (IERC20(borrowShare[token]).totalSupply() == 0) return 1e18;
        return borrowTokenBalance[token].mul(1e18).div(IERC20(borrowShare[token]).totalSupply());
    }

    // How many collateral tokens is it's share token backed by
    function getCollateralShareValue() public view returns(uint256) { // 1e18 precision
        if (IERC20(GLPShare).totalSupply() == 0) return 1e18;
        return totalCollateral.mul(1e18).div(IERC20(GLPShare).totalSupply());
    }

    // Fetch the price of an asset from Chainlink oracle
    function getLatestPrice(address token) private view returns (uint) {
        (
            ,
            int price,
            ,
            ,
        ) = AggregatorV3Interface(priceFeed[token]).latestRoundData();
        return uint(price).mul(1e10); // Normalize to 1e18
    }

    // Price of GLP
    function getCollateralPrice() public view returns (uint) { // 1e18 precision
        uint totalValue;
        for (uint i=0; i<vault.allWhitelistedTokensLength(); i++) {
            totalValue += getLatestPrice(vault.allWhitelistedTokens(i)).mul(IERC20(vault.allWhitelistedTokens(i)).balanceOf(address(vault)));
        }
        uint price = totalValue.mul(1e18).div(IERC20(GLP).totalSupply());
        return uint(price);
    }

    // User's health factor
    function accountHealth(address account) public view returns (uint256) { // 1e18 precision
        if (accountBorrowedValue(account) == 0) return 100e18;
        if (accountCollateralValue(account).mul(1e18).div(accountBorrowedValue(account)) > 100e18) return 100e18;
        return accountCollateralValue(account).mul(1e18).div(accountBorrowedValue(account));
    }

    // How much an user has borrowed in total in USD
    function accountBorrowedValue(address account) public view returns (uint256) { // 1e18 precision
        uint totalBorrowedValue;
        for (uint i=0; i<vault.allWhitelistedTokensLength(); i++) {
            totalBorrowedValue += userDebt(account, vault.allWhitelistedTokens(i)).mul(getLatestPrice(vault.allWhitelistedTokens(i))).div(1e18);
        }  
        return totalBorrowedValue;      
    }

    // Value of an user's collateral in USD
    function accountCollateralValue(address account) public view returns (uint256) { // 1e18 precision
        uint totalCollateralValue = IERC20(GLPShare).balanceOf(account).mul(getCollateralShareValue()).mul(getCollateralPrice()).mul(ltv).div(100);
        return totalCollateralValue;    
    }

    // Annual interest rate of borrowing a token
    function interestRate(address token) public view returns (uint256) { // 1e18 precision, %annual
        return totalBorrowedAmount(token).mul(1e18).div(borrowTokenBalance[token]);
    }

    // How many tokens have been borrowed from liquidity
    function totalBorrowedAmount(address token) private view returns (uint256) {
        return borrowTokenBalance[token].sub(IERC20(token).balanceOf(address(this)));
    }

    // How many tokens can an user borrow
    function borrowingPower(address account, address token) public view returns (uint256) {
        return accountBorrowedValue(account).mul(accountHealth(account)).div(getLatestPrice(token));
    }

    // How much can an user borrow in USD
    function borrowingPowerUSD(address account) public view returns (uint256) {
        return accountBorrowedValue(account).mul(accountHealth(account)).div(1e18);
    }
}
