// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7d17acfb2f12be0a2ad4c08ad4a3d823704b68d6/contracts/utils/math/SafeMath.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
    function mint(address account, uint256 amount) external;
    function burn(address account, uint256 amount) external;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IVault {
    function allWhitelistedTokensLength() external view returns (uint256);
    function allWhitelistedTokens(uint) external view returns (address);
}

contract collateralizeGLP {
    
    using SafeMath for uint;

    mapping(address => bool) public borrowToken; // Token allowed to be deposited/borrowed
    mapping(address => address) public priceFeed; // Price feed for token
    mapping(address => address) public borrowShare; // Share token from deposited token
    mapping(address => uint) public borrowTokenBalance; // Tracks balance of deposited tokens

    mapping(address => address) public collateralTokenPriceFeed; // Price feed for tokens
    mapping(address => uint) public collateralAmount; // User deposited collateral

    uint256 public totalCollateral; // Total GLP deposited

    address public governance;
    IVault public vault;
    address public GLPShare;
    address public GLP;
    address public fGLP;
    address public fsGLP;

    constructor(address _vault) {
        governance = msg.sender;
        vault = IVault(_vault);
    }

    // End user functions

    function depositCollateral(uint256 amount) external {  
        uint amountToMint = amount.mul(10**18).div(getCollateralShareValue());
        IERC20(GLP).transferFrom(msg.sender, address(this), amount);
        IERC20(GLPShare).mint(msg.sender, amountToMint);
        collateralAmount[msg.sender] += amount;
    }

    function withdrawCollateral(uint256 shareAmount) external {
        IERC20(GLP).burn(msg.sender, shareAmount);
        uint amount = shareAmount.mul(getCollateralShareValue()).div(10**18);
        collateralAmount[msg.sender] -= amount;
        IERC20(GLP).transfer(msg.sender, amount);
    }

    function lend(address token, uint256 amount) external {
        require(borrowToken[token] == true, "Token not allowed");
        uint amountToMint = amount.mul(10**18).div(getShareValue(token));
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        IERC20(borrowShare[token]).mint(msg.sender, amountToMint);
        borrowTokenBalance[token] += amount;
    }

    function withdrawAll(address token) external {
        uint amount = IERC20(borrowShare[token]).balanceOf(msg.sender).mul(getShareValue(token)).div(10**18);
        withdraw(token, amount);
    }

    function withdraw(address token, uint256 shareAmount) public {
        uint amountToSend = shareAmount.mul(getShareValue(token)).div(10**18);
        require(amountToSend > IERC20(token).balanceOf(address(this)), "Too much borrowed from treasury to withdraw");
        IERC20(borrowShare[token]).burn(msg.sender, shareAmount);
        borrowTokenBalance[token] -= amountToSend;
        IERC20(token).transfer(msg.sender, amountToSend);
    }

    function borrow() external {

    }

    function repay() external {

    }

    function repayAll() external {

    }

    // Governance functions

    function setGovernance(address _governance) external {
        require(msg.sender == governance, "!Governance");
        governance = _governance;
    }

    function setBorrowToken(address token, address share, address _priceFeed) external {
        require(msg.sender == governance, "!Governance");
        require(borrowShare[token] == address(0), "!Governance");
        borrowShare[token] = share;
        priceFeed[token] = _priceFeed;
        borrowToken[token] = true;
    }

    function setBorrowTokenAllowed(address token, bool allowed) external {
        require(msg.sender == governance, "!Governance");
        borrowToken[token] = allowed;
    }

    function setCollateralTokenFeed(address token, address feed) external {
        require(msg.sender == governance, "!Governance");
        collateralTokenPriceFeed[token] = feed;
    }

    // View functions

    function getShareValue(address token) public view returns(uint256) {
        if (IERC20(borrowShare[token]).totalSupply() == 0) return 1;
        return getBorrowTokenBalance(token).mul(10**18).div(IERC20(borrowShare[token]).totalSupply());
    }

    function getCollateralShareValue() public view returns(uint256) {
        if (IERC20(GLPShare).totalSupply() == 0) return 1;
        return totalCollateral.mul(10**18).div(IERC20(GLPShare).totalSupply());
    }

    function getBorrowTokenBalance(address token) public view returns(uint256) {
        return borrowTokenBalance[token];
    }

    function getLatestPrice(address token) public view returns (uint) {
        (
            , 
            int price,
            ,
            ,
        ) = AggregatorV3Interface(priceFeed[token]).latestRoundData();
        return uint(price);
    }

    function getCollateralPrice() public view returns (uint) {
        uint totalValue;
        for (uint i=0; i<vault.allWhitelistedTokensLength(); i++) {
            totalValue += getLatestPrice(vault.allWhitelistedTokens(i));
        }
        uint price = totalValue * 10**8 / (IERC20(GLP).totalSupply())/10**10; // 1e8 precision
        return uint(price);
    }

    function accountHealth(address account) public view returns (uint256) {
        
    }
}
