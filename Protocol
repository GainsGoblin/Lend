// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7d17acfb2f12be0a2ad4c08ad4a3d823704b68d6/contracts/utils/math/SafeMath.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
    function mint(address account, uint256 amount) external;
    function burn(address account, uint256 amount) external;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IVault {
    function allWhitelistedTokensLength() external view returns (uint256);
    function allWhitelistedTokens(uint) external view returns (address);
}

interface IRewardTracker {
    function depositBalances(address _account, address _depositToken) external view returns (uint256);
    function stakedAmounts(address _account) external view returns (uint256);
    function updateRewards() external;
    function stake(address _depositToken, uint256 _amount) external;
    function stakeForAccount(address _fundingAccount, address _account, address _depositToken, uint256 _amount) external;
    function unstake(address _depositToken, uint256 _amount) external;
    function unstakeForAccount(address _account, address _depositToken, uint256 _amount, address _receiver) external;
    function tokensPerInterval() external view returns (uint256);
    function claim(address _receiver) external returns (uint256);
    function claimForAccount(address _account, address _receiver) external returns (uint256);
    function claimable(address _account) external view returns (uint256);
    function averageStakedAmounts(address _account) external view returns (uint256);
    function cumulativeRewards(address _account) external view returns (uint256);
}

contract collateralizeGLP {
    
    using SafeMath for uint;

    mapping(address => bool) public borrowToken; // Token allowed to be deposited/borrowed
    mapping(address => address) public priceFeed; // Price feed for token
    mapping(address => address) public borrowShare; // Share token from lent token
    mapping(address => uint) public borrowTokenBalance; // Tracks balance of lent tokens

    mapping(address => address) public collateralTokenPriceFeed; // Price feed for tokens
    mapping(address => uint) public tokenDebt; // Tracks amount of tokens owed
    mapping(address => mapping(address => uint)) public borrowedAmount; // User debt
    mapping(address => uint) public interestCheckpoint; // Tracks token accrued interest using time

    uint256 public totalCollateral; // Total GLP deposited

    address public governance;
    IVault public vault;
    address public GLPShare;
    address public GLP;
    address public fGLP;
    address public fsGLP;
    uint public ltv = 80; // 80 is 80% GLP LTV

    constructor(address _vault) {
        governance = msg.sender;
        vault = IVault(_vault);
    }

    // End user functions

    function depositCollateral(uint256 amount) external {
        uint amountToMint = amount.mul(10**18).div(getCollateralShareValue());
        IERC20(GLP).transferFrom(msg.sender, address(this), amount);
        IERC20(GLPShare).mint(msg.sender, amountToMint);
        totalCollateral += amount;
    }

    function withdrawCollateralAll() external {
        uint shareAmount = IERC20(GLPShare).balanceOf(msg.sender);
        withdrawCollateral(shareAmount);
    }

    function withdrawCollateral(uint256 shareAmount) public {
        IERC20(GLPShare).burn(msg.sender, shareAmount);
        uint amount = shareAmount.mul(getCollateralShareValue()).div(10**18);
        IERC20(GLP).transfer(msg.sender, amount);
        totalCollateral -= amount;
    }

    function lend(address token, uint256 amount) external {
        require(borrowToken[token] == true, "Token not allowed");
        uint amountToMint = amount.mul(10**18).div(getShareValue(token));
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        IERC20(borrowShare[token]).mint(msg.sender, amountToMint);
        borrowTokenBalance[token] += amount;
    }

    function withdrawAll(address token) external {
        uint shareAmount = IERC20(borrowShare[token]).balanceOf(msg.sender);
        withdraw(token, shareAmount);
    }

    function withdraw(address token, uint256 shareAmount) public {
        uint amountToSend = shareAmount.mul(getShareValue(token)).div(10**18);
        require(amountToSend > IERC20(token).balanceOf(address(this)), "Too much borrowed from treasury to withdraw");
        IERC20(borrowShare[token]).burn(msg.sender, shareAmount);
        borrowTokenBalance[token] -= amountToSend;
        IERC20(token).transfer(msg.sender, amountToSend);
    }

    function borrow(address token, uint256 tokenAmount) external {
        require(borrowingPower(msg.sender, token) >= tokenAmount, "Not enough borrowing power");
        borrowedAmount[msg.sender][token] += tokenAmount.mul(10**18).div(debtValue(token));
        IERC20(token).transfer(msg.sender, tokenAmount);
    }

    function repay(address token, uint256 tokenAmount) public {
        require(tokenAmount <= borrowedAmount[msg.sender][token].mul(debtValue(token)).div(10**18), "Repaying too much");
        IERC20(token).transferFrom(msg.sender, address(this), tokenAmount);
        borrowedAmount[msg.sender][token] -= tokenAmount.mul(10**18).div(debtValue(token));
    }

    function repayAll(address token) external {
        repay(token, borrowedAmount[msg.sender][token].mul(debtValue(token)).div(10**18));
    }

    // Governance functions

    function setGovernance(address _governance) external {
        require(msg.sender == governance, "!Governance");
        governance = _governance;
    }

    function setBorrowToken(address token, address share, address _priceFeed) external {
        require(msg.sender == governance, "!Governance");
        require(borrowShare[token] == address(0), "!Governance");
        borrowShare[token] = share;
        priceFeed[token] = _priceFeed;
        borrowToken[token] = true;
    }

    function setBorrowTokenAllowed(address token, bool allowed) external {
        require(msg.sender == governance, "!Governance");
        borrowToken[token] = allowed;
    }

    function setCollateralTokenFeed(address token, address feed) external {
        require(msg.sender == governance, "!Governance");
        collateralTokenPriceFeed[token] = feed;
    }

    function setltv(uint _ltv) external {
        require(msg.sender == governance, "!Governance");
        ltv = _ltv;
    }

    // View functions

    function debtValue(address token) public view returns (uint256) { // 1e18 precision
        return (tokenDebt[token].add(getTokenAccruedInterest(token))).mul(10**18).div(totalBorrowedAmount(token));
    }

    function getTokenAccruedInterest(address token) public view returns (uint256) { // 1e18 precision
        uint secondsBorrowed = block.timestamp.sub(interestCheckpoint[token]);
        uint interest = tokenDebt[token].mul(secondsBorrowed).div(31536000); // 31536000 seconds in a year
        return interest;
    }

    function userDebt(address account, address token) public view returns (uint256) {
        return borrowedAmount[account][token].mul(debtValue(token));
    }

    function getShareValue(address token) public view returns (uint256) {
        if (IERC20(borrowShare[token]).totalSupply() == 0) return 10**18;
        return borrowTokenBalance[token].mul(10**18).div(IERC20(borrowShare[token]).totalSupply());
    }

    function getCollateralShareValue() public view returns(uint256) {
        if (IERC20(GLPShare).totalSupply() == 0) return 10**18;
        return totalCollateral.mul(10**18).div(IERC20(GLPShare).totalSupply());
    }

    function getLatestPrice(address token) public view returns (uint) {
        (
            ,
            int price,
            ,
            ,
        ) = AggregatorV3Interface(priceFeed[token]).latestRoundData();
        return uint(price).mul(10**10); // Normalize to 1e18
    }

    function getCollateralPrice() public view returns (uint) { // 1e18 precision
        uint totalValue;
        for (uint i=0; i<vault.allWhitelistedTokensLength(); i++) {
            totalValue += getLatestPrice(vault.allWhitelistedTokens(i)).mul(IERC20(vault.allWhitelistedTokens(i)).balanceOf(address(vault)));
        }
        uint price = totalValue.mul(10**18).div(IERC20(GLP).totalSupply());
        return uint(price);
    }

    function accountHealth(address account) public view returns (uint256) { // 1e18 precision
        return accountCollateralValue(account).mul(10**18).div(accountBorrowedValue(account));
    }

    function accountBorrowedValue(address account) public view returns (uint256) { // 1e18 precision
        uint totalBorrowedValue;
        for (uint i=0; i<vault.allWhitelistedTokensLength(); i++) {
            totalBorrowedValue += borrowedAmount[account][vault.allWhitelistedTokens(i)].mul(getLatestPrice(vault.allWhitelistedTokens(i)));
        }  
        return totalBorrowedValue;      
    }

    function accountCollateralValue(address account) public view returns (uint256) { // 1e18 precision
        uint totalCollateralValue = IERC20(GLPShare).balanceOf(account).mul(getCollateralShareValue()).mul(getCollateralPrice()).mul(ltv).div(100);
        return totalCollateralValue;    
    }

    function interestRate(address token) public view returns (uint256) { // 1e18 precision, %annual
        return totalBorrowedAmount(token).mul(10**18).div(borrowTokenBalance[token]);
    }

    function totalBorrowedAmount(address token) private view returns (uint256) {
        return borrowTokenBalance[token].sub(IERC20(token).balanceOf(address(this)));
    }

    // How many tokens can be borrowed
    function borrowingPower(address account, address token) public view returns (uint256) {
        return accountBorrowedValue(account).mul(accountHealth(account)).div(getLatestPrice(token));
    }
}
